<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="数据库知识点总结"><meta name="keywords" content="数据库"><meta name="author" content="Monkey"><meta name="copyright" content="Monkey"><title>数据库知识点总结 | 猴子笔记</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"N6GP2ERA7A","apiKey":"06f568382110773eba4ced2704c7205b","indexName":"monkey_index","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-事务四大特性（ACID）原子性、一致性、隔离性、持久性？"><span class="toc-number">1.</span> <span class="toc-text">1. 事务四大特性（ACID）原子性、一致性、隔离性、持久性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-事务的并发？事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别？"><span class="toc-number">2.</span> <span class="toc-text">2. 事务的并发？事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-事务的并发问题"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 事务的并发问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-事务的隔离级别"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 事务的隔离级别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别？"><span class="toc-number">3.</span> <span class="toc-text">3. MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-InnoDB存储引擎"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 InnoDB存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-MyISAM存储引擎"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 MyISAM存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-MEMORY存储引擎"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 MEMORY存储引擎</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景？"><span class="toc-number">4.</span> <span class="toc-text">4. MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-事务处理上方面"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 事务处理上方面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-锁级别"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 锁级别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序？"><span class="toc-number">5.</span> <span class="toc-text">5. 查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-执行顺序"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-语句解析顺序"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 语句解析顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-什么是临时表，临时表什么时候删除？"><span class="toc-number">6.</span> <span class="toc-text">6. 什么是临时表，临时表什么时候删除？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-MySQL-B-Tree索引和Hash索引的区别？"><span class="toc-number">7.</span> <span class="toc-text">7. MySQL B+Tree索引和Hash索引的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-B-TREE索引"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 B-TREE索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-HASH索引"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 HASH索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-聚集索引和非聚集索引区别？"><span class="toc-number">8.</span> <span class="toc-text">8. 聚集索引和非聚集索引区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-聚集索引"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 聚集索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-非聚集索引"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 非聚集索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-乐观锁和悲观锁？"><span class="toc-number">9.</span> <span class="toc-text">9. 乐观锁和悲观锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-非关系型数据库和关系型数据库区别，优势比较？"><span class="toc-number">10.</span> <span class="toc-text">10. 非关系型数据库和关系型数据库区别，优势比较？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-非关系型数据库的优势"><span class="toc-number">10.1.</span> <span class="toc-text">10.1 非关系型数据库的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-关系型数据库的优势"><span class="toc-number">10.2.</span> <span class="toc-text">10.2 关系型数据库的优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-数据库三范式，根据某个场景设计数据表？"><span class="toc-number">11.</span> <span class="toc-text">11. 数据库三范式，根据某个场景设计数据表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-使用explain优化sql和索引？"><span class="toc-number">12.</span> <span class="toc-text">12. 使用explain优化sql和索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-什么是内连接、外连接、交叉连接、笛卡尔积等？"><span class="toc-number">13.</span> <span class="toc-text">13.什么是内连接、外连接、交叉连接、笛卡尔积等？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决？"><span class="toc-number">14.</span> <span class="toc-text">14. mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-MySQL有三种锁的级别"><span class="toc-number">14.1.</span> <span class="toc-text">14.1 MySQL有三种锁的级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-什么情况下会造成死锁"><span class="toc-number">14.2.</span> <span class="toc-text">14.2 什么情况下会造成死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-死锁的解决办法"><span class="toc-number">14.3.</span> <span class="toc-text">14.3 死锁的解决办法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-varchar和char的使用场景？"><span class="toc-number">15.</span> <span class="toc-text">15. varchar和char的使用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-mysql-高并发环境解决方案？"><span class="toc-number">16.</span> <span class="toc-text">16. mysql 高并发环境解决方案？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）？"><span class="toc-number">17.</span> <span class="toc-text">17. 数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）？</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Monkey</div><div class="author-info__description text-center">接受变化，拥抱新世界</div><div class="follow-button"><a href="https://github.com/monkeyip">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">13</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">9</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://molunerfinn.com">Molunerfinn</a><a class="author-info-links__name text-center" href="https://piegg.cn">PiEgg</a><a class="author-info-links__name text-center" href="https://piegg.cn">Elody</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">猴子笔记</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">数据库知识点总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-30</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/数据库/">数据库</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">5.4k</span><span class="post-meta__separator">|</span><span>Reading time: 16 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="1-事务四大特性（ACID）原子性、一致性、隔离性、持久性？"><a href="#1-事务四大特性（ACID）原子性、一致性、隔离性、持久性？" class="headerlink" title="1. 事务四大特性（ACID）原子性、一致性、隔离性、持久性？"></a>1. 事务四大特性（ACID）原子性、一致性、隔离性、持久性？</h2><ul>
<li><p>原子性（Atomicity）</p>
<blockquote>
<p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
</blockquote>
</li>
<li><p>一致性（Consistency）</p>
<blockquote>
<p>事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。</p>
</blockquote>
</li>
<li><p>隔离性（Isolation）</p>
<blockquote>
<p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>
</blockquote>
</li>
<li><p>持久性（Durability）</p>
<blockquote>
<p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
</blockquote>
</li>
</ul>
<a id="more"></a>
<h2 id="2-事务的并发？事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别？"><a href="#2-事务的并发？事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别？" class="headerlink" title="2. 事务的并发？事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别？"></a>2. 事务的并发？事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别？</h2><p><em>从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题，然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行，在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行， 事务的隔离级别可以通过隔离事务属性指定。</em></p>
<h3 id="2-1-事务的并发问题"><a href="#2-1-事务的并发问题" class="headerlink" title="2.1 事务的并发问题"></a>2.1 事务的并发问题</h3><ol>
<li><p>脏读</p>
<blockquote>
<p>事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据.</p>
</blockquote>
</li>
<li><p>不可重复读</p>
<blockquote>
<p>事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</p>
</blockquote>
</li>
<li><p>幻读</p>
<blockquote>
<p>幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。</p>
<p>例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。 而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>
</blockquote>
</li>
</ol>
<p><strong>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</strong></p>
<h3 id="2-2-事务的隔离级别"><a href="#2-2-事务的隔离级别" class="headerlink" title="2.2 事务的隔离级别"></a>2.2 事务的隔离级别</h3><p><strong>*数据库隔离级别</strong>：是在在数据库操作中，为了有效保证并发读取数据的正确性提出的。*</p>
<p><em>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</em></p>
<ol>
<li><p>READ UNCOMMITTED（读未提交数据）</p>
<blockquote>
<p>允许事务读取未被其他事务提交的变更数据，会出现脏读、不可重复读和幻读问题。</p>
</blockquote>
</li>
<li><p>READ COMMITTED（读已提交数据）</p>
<blockquote>
<p>只允许事务读取已经被其他事务提交的变更数据，可避免脏读，仍会出现不可重复读和幻读问题。</p>
</blockquote>
</li>
<li><p>REPEATABLE READ（可重复读）</p>
<blockquote>
<p>确保事务可以多次从一个字段中读取相同的值，在此事务持续期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读，仍会出现幻读问题。</p>
</blockquote>
</li>
<li><p>SERIALIZABLE（序列化）</p>
<blockquote>
<p>确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作，可避免所有并发问题，但性能非常低。</p>
</blockquote>
</li>
</ol>
<p>Oracle支持两种事务隔离级别：READ COMMITTED（默认事务隔离级别），SERIALIZABLE。</p>
<p>MySQL支持四种事务隔离级别，其中REPEATABLE READ为默认事务隔离级别。</p>
<h2 id="3-MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别？"><a href="#3-MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别？" class="headerlink" title="3. MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别？"></a>3. MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别？</h2><p><img src="https://images2015.cnblogs.com/blog/851461/201703/851461-20170306202857781-1607368004.png" alt="三大存储引擎区别"></p>
<h3 id="3-1-InnoDB存储引擎"><a href="#3-1-InnoDB存储引擎" class="headerlink" title="3.1 InnoDB存储引擎"></a>3.1 InnoDB存储引擎</h3><p>InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），其它存储引擎都是非事务安全表，支持行锁定和外键，MySQL5.5以后默认使用InnoDB存储引擎。</p>
<p>InnoDB特点： 支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。</p>
<p>如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。</p>
<h3 id="3-2-MyISAM存储引擎"><a href="#3-2-MyISAM存储引擎" class="headerlink" title="3.2 MyISAM存储引擎"></a>3.2 MyISAM存储引擎</h3><p>MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但不支持事务，不支持外键。</p>
<p>MyISAM特点： 插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比较低，也可以使用</p>
<h3 id="3-3-MEMORY存储引擎"><a href="#3-3-MEMORY存储引擎" class="headerlink" title="3.3 MEMORY存储引擎"></a>3.3 MEMORY存储引擎</h3><p>MEMORY存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。</p>
<p>MEMORY特点： 所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。</p>
<p>它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。</p>
<h2 id="4-MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景？"><a href="#4-MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景？" class="headerlink" title="4. MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景？"></a>4. MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景？</h2><h3 id="4-1-事务处理上方面"><a href="#4-1-事务处理上方面" class="headerlink" title="4.1 事务处理上方面"></a>4.1 事务处理上方面</h3><p><strong>MyISAM：强调的是性能，</strong> 每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。</p>
<p><strong>InnoDB：提供事务支持事务，外部键等高级数据库功能。</strong> 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p>
<h3 id="4-2-锁级别"><a href="#4-2-锁级别" class="headerlink" title="4.2 锁级别"></a>4.2 锁级别</h3><p><strong>MyISAM：只支持表级锁，</strong> 用户在操作MyISAM表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。</p>
<p><strong>InnoDB：</strong> 支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p>
<h2 id="5-查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序？"><a href="#5-查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序？" class="headerlink" title="5. 查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序？"></a>5. 查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序？</h2><h3 id="5-1-执行顺序"><a href="#5-1-执行顺序" class="headerlink" title="5.1 执行顺序"></a>5.1 执行顺序</h3><ul>
<li>from:需要从哪个数据表检索数据</li>
<li>where:过滤表中数据的条件</li>
<li>group by:如何将上面过滤出的数据分组</li>
<li>having:对上面已经分组的数据进行过滤的条件</li>
<li>select:查看结果集中的哪个列，或列的计算结果</li>
<li>order by :按照什么样的顺序来查看返回的数据</li>
</ul>
<h3 id="5-2-语句解析顺序"><a href="#5-2-语句解析顺序" class="headerlink" title="5.2 语句解析顺序"></a>5.2 语句解析顺序</h3><p>from后面的表关联，是自右向左解析 而where条件的解析顺序是自下而上的。</p>
<p>也就是说，在写SQL的时候，尽量把数据量小的表放在最右边来进行关联（用小表去匹配大表），而把能筛选出小量数据的条件放在where语句的最左边 （用小表去匹配大表）</p>
<h2 id="6-什么是临时表，临时表什么时候删除？"><a href="#6-什么是临时表，临时表什么时候删除？" class="headerlink" title="6. 什么是临时表，临时表什么时候删除？"></a>6. 什么是临时表，临时表什么时候删除？</h2><p>MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。</p>
<p>使用其他MySQL客户端程序连接MySQL数据库服务器来创建临时表，那么只有在关闭客户端程序时才会销毁临时表，当然也可以手动删除。</p>
<h2 id="7-MySQL-B-Tree索引和Hash索引的区别？"><a href="#7-MySQL-B-Tree索引和Hash索引的区别？" class="headerlink" title="7. MySQL B+Tree索引和Hash索引的区别？"></a>7. MySQL B+Tree索引和Hash索引的区别？</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> act_info(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">act_id <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">"活动id"</span>,</span><br><span class="line">act_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">"活动名称"</span>,</span><br><span class="line">act_date datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>),</span><br><span class="line"><span class="keyword">KEY</span> idx_actid_name(act_id,act_name) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=UTF8 ROW_FORMAT=<span class="keyword">COMPACT</span> <span class="keyword">COMMENT</span> <span class="string">"活动记录表"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="7-1-B-TREE索引"><a href="#7-1-B-TREE索引" class="headerlink" title="7.1 B-TREE索引"></a>7.1 B-TREE索引</h3><ol>
<li><p>B-TREE索引的特点</p>
<ul>
<li>B-TREEB-TREE以B+树结构存储数据，大大加快了数据的查询速度</li>
<li>B-TREE索引在范围查找的SQL语句中更加适合（顺序存储）</li>
</ul>
</li>
<li><p>B-TREE索引使用场景</p>
<ul>
<li>全值匹配的查询SQL，如 where act_id= ‘1111_act’</li>
<li>联合索引汇中匹配到最左前缀查询，如联合索引 KEY idx_actid_name(act_id,act_name) USING BTREE，只要条件中使用到了联合索引的第一列，就会用到该索引，但如果查询使用到的是联合索引的第二列act_name，该SQL则便无法使用到该联合索引（注：覆盖索引除外）</li>
<li>匹配模糊查询的前匹配，如where act_name like ‘11_act%’</li>
<li>匹配范围值的SQL查询，如where act_date &gt; ‘9865123547215’（not in和&lt;&gt;无法使用索引）</li>
<li>覆盖索引的SQL查询，就是说select出来的字段都建立了索引</li>
</ul>
</li>
</ol>
<h3 id="7-2-HASH索引"><a href="#7-2-HASH索引" class="headerlink" title="7.2 HASH索引"></a>7.2 HASH索引</h3><p>HASH的特点</p>
<ul>
<li>Hash索引基于Hash表实现，只有查询条件精确匹配Hash索引中的所有列才会用到hash索引</li>
<li>存储引擎会为Hash索引中的每一列都计算hash码，Hash索引中存储的即hash码，所以每次读取都会进行两次查询</li>
<li>Hash索引无法用于排序</li>
<li>Hash不适用于区分度小的列上，如性别字段</li>
</ul>
<h2 id="8-聚集索引和非聚集索引区别？"><a href="#8-聚集索引和非聚集索引区别？" class="headerlink" title="8. 聚集索引和非聚集索引区别？"></a>8. 聚集索引和非聚集索引区别？</h2><p><em>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</em></p>
<h3 id="8-1-聚集索引"><a href="#8-1-聚集索引" class="headerlink" title="8.1 聚集索引"></a>8.1 聚集索引</h3><p><strong>聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。</strong></p>
<p>聚集索引类似于新华字典中用拼音去查找汉字，拼音检索表于书记顺序都是按照a~z排列的，就像相同的逻辑顺序于物理顺序一样，当你需要查找a,ai两个读音的字，或是想一次寻找多个傻(sha)的同音字时，也许向后翻几页，或紧接着下一行就得到结果了。</p>
<h3 id="8-2-非聚集索引"><a href="#8-2-非聚集索引" class="headerlink" title="8.2 非聚集索引"></a>8.2 非聚集索引</h3><p><strong>非聚集索引制定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。</strong></p>
<p>非聚集索引类似在新华字典上通过偏旁部首来查询汉字，检索表也许是按照横、竖、撇来排列的，但是由于正文中是a~z的拼音顺序，所以就类似于逻辑地址于物理地址的不对应。同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。</p>
<h2 id="9-乐观锁和悲观锁？"><a href="#9-乐观锁和悲观锁？" class="headerlink" title="9. 乐观锁和悲观锁？"></a>9. 乐观锁和悲观锁？</h2><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。 </p>
<p>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
<ul>
<li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</li>
<li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</li>
</ul>
<p><a href="https://www.open-open.com/lib/view/open1452046967245.html" target="_blank" rel="noopener">更多详情</a></p>
<h2 id="10-非关系型数据库和关系型数据库区别，优势比较？"><a href="#10-非关系型数据库和关系型数据库区别，优势比较？" class="headerlink" title="10. 非关系型数据库和关系型数据库区别，优势比较？"></a>10. 非关系型数据库和关系型数据库区别，优势比较？</h2><h3 id="10-1-非关系型数据库的优势"><a href="#10-1-非关系型数据库的优势" class="headerlink" title="10.1 非关系型数据库的优势"></a>10.1 非关系型数据库的优势</h3><ol>
<li>性能</li>
</ol>
<p>NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</p>
<ol start="2">
<li>可扩展性</li>
</ol>
<p>同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</p>
<h3 id="10-2-关系型数据库的优势"><a href="#10-2-关系型数据库的优势" class="headerlink" title="10.2 关系型数据库的优势"></a>10.2 关系型数据库的优势</h3><ol>
<li>复杂查询</li>
</ol>
<p>　　可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</p>
<ol start="2">
<li>事务支持</li>
</ol>
<p>　　使得对于安全性能很高的数据访问要求得以实现。</p>
<p><strong>小结：对于这两类数据库，对方的优势就是自己的弱势，反之亦然。NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，比如MongoDB。对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如Redis set nx。</strong></p>
<h2 id="11-数据库三范式，根据某个场景设计数据表？"><a href="#11-数据库三范式，根据某个场景设计数据表？" class="headerlink" title="11. 数据库三范式，根据某个场景设计数据表？"></a>11. 数据库三范式，根据某个场景设计数据表？</h2><ol>
<li>第一范式(确保每列保持原子性)</li>
</ol>
<p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</p>
<p>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。</p>
<p><img src="https://pic4.zhimg.com/v2-941c875cedce9b04fab8f2ce3b97b6a3_b.jpg" alt></p>
<p>上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。 </p>
<ol start="2">
<li>第二范式(确保表中的每列都和主键相关)</li>
</ol>
<p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p>
<p>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示。</p>
<p><img src="https://pic3.zhimg.com/v2-c78e7cafd9f85fc476cd0b7679ee7786_b.jpg" alt="订单信息表"></p>
<p>这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。</p>
<p>而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示。</p>
<p><img src="https://pic4.zhimg.com/v2-1ef6571529f17bcbd2cfbb251169cd7b_b.jpg" alt></p>
<p>这样设计，在很大程度上减小了数据库的冗余。如果要获取订单的商品信息，使用商品编号到商品信息表中查询即可。 </p>
<ol start="3">
<li>第三范式(确保每列都和主键列直接相关,而不是间接相关)</li>
</ol>
<p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p>
<p>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。</p>
<p><img src="https://pic3.zhimg.com/v2-4fe0e9bf91221080e607eed0add22d96_b.jpg" alt></p>
<p>这样在查询订单信息的时候，就可以使用客户编号来引用客户信息表中的记录，也不必在订单信息表中多次输入客户信息的内容，减小了数据冗余。</p>
<h2 id="12-使用explain优化sql和索引？"><a href="#12-使用explain优化sql和索引？" class="headerlink" title="12. 使用explain优化sql和索引？"></a>12. 使用explain优化sql和索引？</h2><p><a href="https://zhuanlan.zhihu.com/p/56529089" target="_blank" rel="noopener">知乎详细回答</a></p>
<h2 id="13-什么是内连接、外连接、交叉连接、笛卡尔积等？"><a href="#13-什么是内连接、外连接、交叉连接、笛卡尔积等？" class="headerlink" title="13.什么是内连接、外连接、交叉连接、笛卡尔积等？"></a>13.什么是内连接、外连接、交叉连接、笛卡尔积等？</h2><ul>
<li><p>内连接(INNER JOIN)</p>
<ul>
<li>等值连接</li>
<li>自然连接</li>
<li>不等连接  </li>
</ul>
</li>
<li><p>外连接(OUTER JOIN)  </p>
<ul>
<li>左外连接(LEFT OUTER JOIN或LEFT JOIN)</li>
<li>右外连接(RIGHT OUTER JOIN或RIGHT JOIN) </li>
<li>全外连接(FULL OUTER JOIN或FULL JOIN)</li>
</ul>
</li>
</ul>
<ul>
<li>交叉连接(CROSS JOIN)</li>
</ul>
<p>没有WHERE 子句，它返回连接表中所有数据行的笛卡尔积</p>
<h2 id="14-mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决？"><a href="#14-mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决？" class="headerlink" title="14. mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决？"></a>14. mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决？</h2><h3 id="14-1-MySQL有三种锁的级别"><a href="#14-1-MySQL有三种锁的级别" class="headerlink" title="14.1 MySQL有三种锁的级别"></a>14.1 MySQL有三种锁的级别</h3><p><strong>表级锁：</strong> 开销小，加锁快；<strong>不会出现死锁；</strong> 锁定粒度大，发生锁冲突的概率最高,并发度最低。</p>
<p><strong>行级锁：</strong> 开销大，加锁慢；<strong>会出现死锁；</strong> 锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p>
<p><strong>页面锁：</strong> 开销和加锁时间界于表锁和行锁之间；<strong>会出现死锁；</strong> 锁定粒度界于表锁和行锁之间，并发度一般</p>
<h3 id="14-2-什么情况下会造成死锁"><a href="#14-2-什么情况下会造成死锁" class="headerlink" title="14.2 什么情况下会造成死锁"></a>14.2 什么情况下会造成死锁</h3><p>所谓死锁: 是指两个或两个以上的进程在执行过程中。因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程。</p>
<p>表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。</p>
<p><strong>死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。</strong></p>
<h3 id="14-3-死锁的解决办法"><a href="#14-3-死锁的解决办法" class="headerlink" title="14.3 死锁的解决办法"></a>14.3 死锁的解决办法</h3><ul>
<li>查出的线程杀死 kill</li>
<li><p>设置锁的超时时间</p>
<h2 id="15-varchar和char的使用场景？"><a href="#15-varchar和char的使用场景？" class="headerlink" title="15. varchar和char的使用场景？"></a>15. varchar和char的使用场景？</h2></li>
</ul>
<p>char的长度是不可变的，而varchar的长度是可变的。</p>
<p>定义一个char[10]和varchar[10]。如果存进去的是‘csdn’,那么char所占的长度依然为10，除了字符‘csdn’外，后面跟六个空格，varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。</p>
<p>char的存取速度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找。char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。varchar是以空间效率为首位。</p>
<p>char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。</p>
<p>varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。</p>
<p>两者的存储数据都非unicode的字符数据。</p>
<h2 id="16-mysql-高并发环境解决方案？"><a href="#16-mysql-高并发环境解决方案？" class="headerlink" title="16. mysql 高并发环境解决方案？"></a>16. mysql 高并发环境解决方案？</h2><p> MySQL高并发环境解决方案：分库、分表、分布式、增加二级缓存。</p>
<p><strong>需求分析：</strong> 互联网单位 每天大量数据读取，写入，并发性高。</p>
<p><strong>现有解决方式：</strong> 水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。</p>
<p><strong>集群方案：</strong> 解决DB宕机带来的单点DB不能访问问题。</p>
<p><strong>读写分离策略：</strong> 极大限度提高了应用中Read数据的速度和并发量。无法解决高写入压力。</p>
<h2 id="17-数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）？"><a href="#17-数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）？" class="headerlink" title="17. 数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）？"></a>17. 数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）？</h2><p><a href="https://www.cnblogs.com/Bozh/archive/2013/03/18/2966494.html" target="_blank" rel="noopener">更多详情</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Monkey</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://monkeyip.github.io/2019/04/30/数据库知识点总结/">https://monkeyip.github.io/2019/04/30/数据库知识点总结/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/数据库/">数据库</a></div><div class="social-share" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/04/30/Hive知识点总结/"><i class="fa fa-chevron-left">  </i><span>Hive知识点总结</span></a></div><div class="next-post pull-right"><a href="/2019/04/25/Hive数据倾斜优化总结/"><span>Hive数据倾斜优化总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '6471dab7a33572779bcb',
  clientSecret: '2cea5b126504ccdfe452686c4b69ebf03418831a',
  repo: 'monkeyip.github.io',
  owner: 'monkeyip',
  admin: 'monkeyip',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By Monkey</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>